package framework.main;

import framework.entity.Camera;
import framework.entity.Entity;
import framework.entity.Light;
import framework.environment.Engine;
import framework.environment.Scene;
import framework.hardware.Display;
import framework.model.Model;
import framework.model.TexturedModel;
import framework.io.Resources;

import java.util.Arrays;
import java.util.Random;

import static framework.hardware.Display.getLwjglVersionMessage;
import static framework.hardware.Display.getOpenGlVersionMessage;

public class Main
{

    public static Model model;
    public static TexturedModel tm;
    public static Entity ent;
    public static Light light;
    public static Scene scene;

    private static void start() {

        Display.createDisplay(1280, 720);
        Display.setShowFPSTitle(true);

        Arrays.asList("OpenGL: " + getOpenGlVersionMessage(), "LWJGL: " + getLwjglVersionMessage()).forEach(
                System.out::println);
        Engine.createThreads();
    }

    public static void main(String... args)
    {
        start();
        scene = new Scene();
        Resources.createResourcePool();

        tm = new TexturedModel(
                Resources.getModel("box"),
                Resources.getTexture("box")
        );


        light = new Light();
        light.setColor(1,1, 1);
        light.setPosition(0, 0, 20);

        ent = new Entity(tm);
        ent.setPosition(0, 0, -20);
        ent.setRotation(0, 180,0);
        ent.setScale(1, 1, 1);

        Random r = new Random();

        for(int i = 0; i < 900; i++)
        {
            Entity entity = new Entity(tm);
            entity.setPosition(r.nextFloat(200) - 100, r.nextFloat(100) - 50, -r.nextFloat(100));
            entity.setScale(1,1, 1);
            scene.add(entity);
        }

        Camera camera = new Camera();

        scene.add(ent);
        scene.add(light);
        scene.setCamera(camera);

        Engine.setScene(scene);
        Engine.start();

    }
}


package framework.renderer;

import framework.entity.Entity;
import framework.environment.Scene;
import framework.hardware.Display;
import framework.lang.Mat4;
import framework.model.TexturedModel;
import framework.shader.GLShader;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static framework.shader.GLShader.EntityShader;
import static framework.shader.GLShader.disableVertexArrays;
import static framework.shader.GLShader.enableVertexArrays;
import static org.lwjgl.opengl.GL30.*;

public class MasterRenderer {
    public static float fov = 70;
    public static float nearPlane = 0.1f;
    public static float farPlane = 100_000;
    public static float SKY_RED = 0.95f;
    public static float SKY_GREEN = 0.9f;
    public static float SKY_BLUE = 0.67f;
    private static Mat4 projectionMatrix;
    private static Map<TexturedModel, List<Entity>> entry;


    public static void setRenderer()
    {
        entry = new HashMap<>();
        projectionMatrix = new Mat4();
        updateProjectionMatrix();
        GLShader.initializeShaders();
        GLShader.bind(EntityShader.program);
        GLShader.loadUniform("projectionMatrix", projectionMatrix);
        GLShader.unbind();
        enableCulling();
        enableDepthTest();
    }

    private static void enableDepthTest()
    {
        glEnable(GL_DEPTH_TEST);
    }

    public static void enableCulling() {
        glEnable(GL_CULL_FACE);
        glCullFace(GL_BACK);
    }

    public static void disableCulling() {
        glDisable(GL_CULL_FACE);
    }

    public static void processEntity() {

    }

    public static void prepare() {
        glEnable(GL_DEPTH_TEST);    // test which triangles are in front and render them in the correct order
        glClearColor(0,0, 0, 1);      // Load selected color into the color buffer
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);     // Clear the screen and draw with color in color buffer
    }

    private static float aspectRatio;
    private static float yScale;
    private static float xScale;
    private static float frustumLength;

    public static void updateProjectionMatrix()
    {
        projectionMatrix.identity();
        aspectRatio = (float) Display.getWidth() / (float) Display.getHeight();
        yScale = (float) (1f / Math.tan(Math.toRadians(fov / 2f)));
        xScale = yScale / aspectRatio;
        frustumLength = farPlane - nearPlane;

        projectionMatrix.m00 = xScale;
        projectionMatrix.m11 = yScale;
        projectionMatrix.m22 = -((farPlane + nearPlane) / frustumLength);
        projectionMatrix.m23 = -1f;
        projectionMatrix.m32 = -((2f * nearPlane * farPlane) / frustumLength);
        projectionMatrix.m33 = 0f;
    }

    public static Mat4 getProjectionMatrix()
    {
        return projectionMatrix;
    }

    public static void render(Scene scene) {
        GLShader.bind(EntityShader.program);
        enableVertexArrays();
        GLShader.loadUniform("viewMatrix", scene.camera.getViewMatrix());
        GLShader.loadLights(scene.lights);
        processEntities(scene.entities);
        renderBatchedEntities();
        disableVertexArrays();
        GLShader.unbind();
        entry.clear();
    }

    private static void processEntities(List<Entity> entities) {
        for (Entity e : entities) {
            TexturedModel model = e.getModel();
            List<Entity> list = entry.computeIfAbsent(model, k -> new ArrayList<>());
            list.add(e);
        }
    }

    private static void renderBatchedEntities() {
        for (Map.Entry<TexturedModel, List<Entity>> ent : entry.entrySet()) {
            TexturedModel model = ent.getKey();
            List<Entity> entities = ent.getValue();

            // Bind the VAO for the entire batch
            glBindVertexArray(model.getModel().getVaoId());

            // Bind the texture for the entire batch
            glActiveTexture(GL_TEXTURE0);
            glBindTexture(GL_TEXTURE_2D, model.getTexture().getTextureId());
            GLShader.loadTexture(model.getTexture());

            // Render each entity in the batch
            for (Entity entity : entities) {
                renderEntity(entity);
            }

            // Cleanup
            glBindVertexArray(0);
        }
    }



    private static void renderEntity(Entity entity) {
        // Load uniforms that are specific to each entity
        GLShader.loadUniform("transformationMatrix", entity.getTransformationMatrix());
        GLShader.loadUniform("hasTexture", true);
        GLShader.loadUniform("backgroundColor", entity.getRed(), entity.getGreen(), entity.getBlue(), entity.getAlpha());

        // Draw the entity
        glDrawElements(GL_TRIANGLES, entity.getModel().getModel().getVertexCount(), GL_UNSIGNED_INT, 0);

    }
}

vertex shader:

#version 410 core
#define MAX_LIGHTS 100 // Define your maximum number of lights here

// structures
struct Light {
    vec3 pos;
    vec3 color;
    float intensity;

    // attenuation
    float constant;
    float linear;
    float quadratic;
    float distance; // < 0 means infinite distance

    // matrices
    mat4 lightSpaceMatrix;
};

struct Texture {
    sampler2D diffuse;
    sampler2D normal;
    sampler2D specular;
    bool hasDiffuse;
    bool hasNormal;
    bool hasSpecular;
};

struct Material {
    float shineDamp;
    float reflectivity;
};

// from the vertex shader
in vec2 passTex;
in vec3 surfaceNorm;
in vec4 worldPos;
in vec3 toCamera;

// uniforms
uniform sampler2D modelTexture;
uniform vec4 backgroundColor;
uniform bool hasTexture;
uniform Light lights[MAX_LIGHTS];
uniform int lightCount;
uniform float ambient;
uniform Material material;

// output color (final)
out vec4 outColor;

// global variables

vec4 paint(bool flag)
{
    if(flag)
        return texture(modelTexture, passTex);
    else
        return normalize(backgroundColor);
}

vec3 highlight(vec3 normal, int lightIndex)
{
    vec3 unitCamera = normalize(toCamera);
    vec3 reflectLight = reflect(-unitCamera, normal);

    float specular = max(dot(reflectLight, unitCamera), 0);
    float damp = pow(specular, material.shineDamp);

    return damp * lights[lightIndex].color;
}

vec4 processLighting(void)
{
    vec3 unitLightVector;
    vec3 diffuse;
    for(int i = 0; i < 1; i++)
    {
        vec3 unitLightVector = normalize(lights[i].pos - worldPos.xyz);
        vec3 unitNormal = normalize(surfaceNorm);

        float lightDot = dot(unitNormal, unitLightVector);
        float brightness = max(lightDot, 0);

        diffuse += (brightness * normalize(lights[i].color)) + highlight(unitNormal, i) * material.reflectivity;
    }
    return vec4(diffuse, 1);
}

void main(void)
{
    outColor = paint(hasTexture);
    outColor *= processLighting();
    outColor = vec4(1);
}

fragment:
#version 410 core
#define MAX_LIGHTS 100 // Define your maximum number of lights here

// structures
struct Light {
    vec3 pos;
    vec3 color;
    float intensity;

    // attenuation
    float constant;
    float linear;
    float quadratic;
    float distance; // < 0 means infinite distance

    // matrices
    mat4 lightSpaceMatrix;
};

struct Texture {
    sampler2D diffuse;
    sampler2D normal;
    sampler2D specular;
    bool hasDiffuse;
    bool hasNormal;
    bool hasSpecular;
};

struct Material {
    float shineDamp;
    float reflectivity;
};

// from the vertex shader
in vec2 passTex;
in vec3 surfaceNorm;
in vec4 worldPos;
in vec3 toCamera;

// uniforms
uniform sampler2D modelTexture;
uniform vec4 backgroundColor;
uniform bool hasTexture;
uniform Light lights[MAX_LIGHTS];
uniform int lightCount;
uniform float ambient;
uniform Material material;

// output color (final)
out vec4 outColor;

// global variables

vec4 paint(bool flag)
{
    if(flag)
        return texture(modelTexture, passTex);
    else
        return normalize(backgroundColor);
}

vec3 highlight(vec3 normal, int lightIndex)
{
    vec3 unitCamera = normalize(toCamera);
    vec3 reflectLight = reflect(-unitCamera, normal);

    float specular = max(dot(reflectLight, unitCamera), 0);
    float damp = pow(specular, material.shineDamp);

    return damp * lights[lightIndex].color;
}

vec4 processLighting(void)
{
    vec3 unitLightVector;
    vec3 diffuse;
    for(int i = 0; i < 1; i++)
    {
        vec3 unitLightVector = normalize(lights[i].pos - worldPos.xyz);
        vec3 unitNormal = normalize(surfaceNorm);

        float lightDot = dot(unitNormal, unitLightVector);
        float brightness = max(lightDot, 0);

        diffuse += (brightness * normalize(lights[i].color)) + highlight(unitNormal, i) * material.reflectivity;
    }
    return vec4(diffuse, 1);
}

void main(void)
{
    outColor = paint(hasTexture);
    outColor *= processLighting();
    outColor = vec4(1);
}

package framework.shader;

import framework.entity.Light;
import framework.lang.Mat4;
import framework.io.Resources;
import framework.textures.Texture;
import framework.util.Buffer;
import org.lwjgl.opengl.GL40;
import org.lwjgl.opengl.GL41;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.FloatBuffer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import static framework.shader.GLShader.ShaderProgram.*;
import static org.lwjgl.opengl.GL11.glGetError;
import static org.lwjgl.opengl.GL11C.GL_FALSE;
import static org.lwjgl.opengl.GL20.GL_COMPILE_STATUS;
import static org.lwjgl.opengl.GL20.GL_FRAGMENT_SHADER;
import static org.lwjgl.opengl.GL20.GL_VERTEX_SHADER;
import static org.lwjgl.opengl.GL20.glAttachShader;
import static org.lwjgl.opengl.GL20.glBindAttribLocation;
import static org.lwjgl.opengl.GL20.glCompileShader;
import static org.lwjgl.opengl.GL20.glCreateProgram;
import static org.lwjgl.opengl.GL20.glCreateShader;
import static org.lwjgl.opengl.GL20.glDeleteProgram;
import static org.lwjgl.opengl.GL20.glDeleteShader;
import static org.lwjgl.opengl.GL20.glDetachShader;
import static org.lwjgl.opengl.GL20.glDisableVertexAttribArray;
import static org.lwjgl.opengl.GL20.glEnableVertexAttribArray;
import static org.lwjgl.opengl.GL20.glGetShaderInfoLog;
import static org.lwjgl.opengl.GL20.glGetShaderi;
import static org.lwjgl.opengl.GL20.glGetUniformLocation;
import static org.lwjgl.opengl.GL20.glLinkProgram;
import static org.lwjgl.opengl.GL20.glShaderSource;
import static org.lwjgl.opengl.GL20.glUniform1f;
import static org.lwjgl.opengl.GL20.glUniform1i;
import static org.lwjgl.opengl.GL20.glUniform2f;
import static org.lwjgl.opengl.GL20.glUniform3f;
import static org.lwjgl.opengl.GL20.glUniform4f;
import static org.lwjgl.opengl.GL20.glUniformMatrix4fv;
import static org.lwjgl.opengl.GL20.glUseProgram;
import static org.lwjgl.opengl.GL20.glValidateProgram;

public final class GLShader
{
    public static final String vertexPrefix = "glsl" + File.separator + "vertex" + File.separator;
    public static final String fragmentPrefix =  "glsl" + File.separator + "fragment" + File.separator;
    private static FloatBuffer matrix = Buffer.createFloatBuffer(16);
    private static ShaderProgram currentProgram;

    public static abstract class ShaderProgram
    {

        public static class Struct
        {
            public String[] fields;
            public String name;

            public Struct(String name, String... fields)
            {
                this.name = name;
                this.fields = fields;
            }
            private String field(String name)
            {
                return this.name + "." + name;
            }

            private String field(int index, String name)
            {
                return this.name + "[" + index + "]." + name;
            }

            public void setName(String name)
            {
                this.name = name;
            }

            public String getName()
            {
                return name;
            }
        }

        private int programId;
        private int vertex;
        private int fragment;
        Map<String, Integer> uniforms;
        List<String> attributes;

        public ShaderProgram(int id, int vertex, int fragment)
        {
            programId = id;
            this.vertex = vertex;
            this.fragment = fragment;
            uniforms = new HashMap<>();
            attributes = new ArrayList<>();
        }

        protected void addAttribute(String name)
        {
            attributes.add(name);
            bindAttribute(attributes.size() - 1, name);
        }

        protected void addUniform(String name, int index)
        {
            for(int i = 0; i < index; i++)
            {
                String uniformName = name + "[" + i + "]";
                uniforms.put(uniformName, getUniformLocation(uniformName));
            }
        }

        protected void addUniform(Struct struct, int index)
        {
            for(int i = 0; i < index; i++)
                for(String s : struct.fields)
                {
                    String name = struct.name + "[" + i + "]." + s;
                    uniforms.put(name, getUniformLocation(name));
                    System.out.println(name + " " +  getUniformLocation(name));
                }
        }

        protected void addUniform(Struct struct)
        {
            for(String s : struct.fields)
            {
                String name = struct.name + "." + s;
                uniforms.put(name, getUniformLocation(name));
                System.out.println(name + " " +  getUniformLocation(name));
            }
        }

        protected void addUniform(String name)
        {
            uniforms.put(name, getUniformLocation(name));
            System.out.println(name + " " + getUniformLocation(name));
        }

        protected int getUniformLocation(String name)
        {
            return glGetUniformLocation(programId, name);
        }

        protected void bindAttribute(int attribute, String variable)
        {
            glBindAttribLocation(programId, attribute, variable);
        }

        protected abstract void bindAttributes();

        protected abstract void getAllUniformLocations();
    }

    public static void initializeShaders()
    {
        EntityShader.initializeShader();
    }

    private static void getAllUniformLocations(ShaderProgram program)
    {
        program.getAllUniformLocations();
    }

    private static void linkAndValidateProgram(ShaderProgram program)
    {
        glLinkProgram(program.programId);
        glValidateProgram(program.programId);
    }

    public static void enableVertexArrays()
    {
        int x = currentProgram.attributes.size();
        for(int i = 0; i < x; i++)
            glEnableVertexAttribArray(i);
    }

    public static void disableVertexArrays()
    {
        if(currentProgram == null)
            return;
        int x = currentProgram.attributes.size();
        for(int i = 0; i < x; i++)
            glDisableVertexAttribArray(i);
    }

    public static void loadUniform(String name, float value)
    {
        loadFloat(currentProgram.uniforms.get(name), value);
    }

    public static void loadUniform(String name, float x, float y)
    {
        loadVector(currentProgram.uniforms.get(name), x, y);
    }

    public static void loadUniform(String name, float x, float y, float z)
    {
        loadVector(currentProgram.uniforms.get(name), x, y, z);
    }

    public static void loadUniform(String name, float x, float y, float z, float w)
    {
        loadVector(currentProgram.uniforms.get(name), x, y, z, w);
    }

    public static void loadUniform(String name, int value)
    {
        loadInteger(currentProgram.uniforms.get(name), value);
    }

    public static void loadUniform(String name, boolean flag)
    {
        loadBool(currentProgram.uniforms.get(name), flag);
    }

    public static void loadUniform(String name, Mat4 matrix)
    {
        loadMatrix(currentProgram.uniforms.get(name), matrix);
    }

    public static void loadInteger(int location, int value)
    {
        glUniform1i(location, value);
    }

    public static void loadFloat(int location, float value)
    {
        glUniform1f(location, value);
    }

    public static void loadVector(int location, float x, float y)
    {
        glUniform2f(location, x, y);
    }

    public static void loadVector(int location, float x, float y, float z)
    {
        glUniform3f(location, x, y, z);
    }

    public static void loadVector(int location, float x, float y, float z, float w)
    {
        glUniform4f(location, x, y, z, w);
    }

    public static void loadBool(int location,boolean flag)
    {
        glUniform1f(location, flag? 1 : 0);
    }

    public static void loadMatrix(int location, Mat4 matrix)
    {
        GLShader.matrix.clear();
        matrix.store(GLShader.matrix);
        GLShader.matrix.flip();
        glUniformMatrix4fv(location, false, GLShader.matrix);
    }

    public static void unbind()
    {
        glUseProgram(0);
        currentProgram = null;
    }

    public static void setCurrentProgram(ShaderProgram program)
    {
        currentProgram = program;
    }

    private static void resetCurrentProgram()
    {
        currentProgram = null;
    }

    public static void bind(ShaderProgram program)
    {
        currentProgram = program;
        glUseProgram(currentProgram.programId);
    }

    protected static void bindAttributes(ShaderProgram program)
    {
        program.bindAttributes();
    }

    private static int loadShader(String file, int type)
    {
        StringBuilder source = new StringBuilder();
        try(BufferedReader reader = new BufferedReader(new InputStreamReader(Objects.requireNonNull(Resources.class.getResourceAsStream(file))))) {
            String line;
            while((line = reader.readLine()) != null)
                source.append(line).append("\n");
        }
        catch(IOException e) {
            throw new RuntimeException("Could not read file!");
        }
        int shader = glCreateShader(type);
        glShaderSource(shader, source.toString());
        glCompileShader(shader);
        if(glGetShaderi(shader, GL_COMPILE_STATUS) == GL_FALSE)
            throw new RuntimeException(glGetShaderInfoLog(shader) + "\nCould not compile shader: " + file);
        return shader;
    }

    private static void destroyShaderProgram(ShaderProgram program)
    {
        glDetachShader(program.programId, program.vertex);
        glDetachShader(program.programId, program.fragment);
        glDeleteShader(program.vertex);
        glDeleteShader(program.fragment);
        glDeleteProgram(program.programId);
    }

    public static void destroy()
    {
        EntityShader.destroy();
    }

    /*
    ===========================================================================================================================
    Private static methods for utility classes

        - These are for methods that are used for other shaders
    ===========================================================================================================================
     */
    public static void loadLight(Light light)
    {
        EntityShader.loadLight(light);
    }

    public static void loadLights(List<Light> lights)
    {
        EntityShader.loadLights(lights);
    }

    public static void loadTexture(Texture texture)
    {
        EntityShader.loadTexture(texture);
    }


    /*
    ===========================================================================================================================
    Shader Classes

        - These are for shaders that are used for this engine
    ===========================================================================================================================
     */
    public static class EntityShader
    {
        private static String vertex = GLShader.vertexPrefix + "EntityVertexShader.glsl";
        private static String fragment = GLShader.fragmentPrefix + "EntityFragmentShader.glsl";
        public static ShaderProgram program;

        public static void initializeShader()
        {
            int vert = loadShader(vertex,GL_VERTEX_SHADER);
            int frag = loadShader(fragment,GL_FRAGMENT_SHADER);
            int id = glCreateProgram();
            program = new ShaderProgram(id, vert, frag)
            {
                @Override
                protected void bindAttributes()
                {
                    addAttribute("pos");
                    addAttribute("tex");
                    addAttribute("normal");
                }

                @Override
                protected void getAllUniformLocations()
                {
                    addUniform("transformationMatrix");
                    addUniform("projectionMatrix");
                    addUniform("viewMatrix");
                    addUniform("hasTexture");
                    addUniform("backgroundColor");
                    addUniform("lightCount");
                    addUniform(Light.getStruct(), 1);
                    addUniform(Texture.getStruct());
                }
            };
            setCurrentProgram(program);
            glAttachShader(id, vert);
            glAttachShader(id, frag);
            bindAttributes(program);
            linkAndValidateProgram(program);

            getAllUniformLocations(program);
            resetCurrentProgram();
        }

        public static void destroy()
        {
            unbind();
            destroyShaderProgram(program);
        }

        public static void loadLight(Light light)
        {
            Struct str = Light.getStruct();
            loadUniform(str.field("pos"), light.getPosX(), light.getPosY(), light.getPosZ());
            loadUniform(str.field("color"), light.r, light.g, light.b);
        }

        public static void loadLight(Light light, int index)
        {
            Struct str = Light.getStruct();
            loadUniform(str.field(index, "pos"), light.getPosX(), light.getPosY(), light.getPosZ());
            loadUniform(str.field(index, "color"), light.r, light.g, light.b);
        }

        public static void loadLights(List<Light> lights)
        {
            int index = 0;
            for(Light l : lights)
            {
                loadLight(l, index++);
            }

        }

        public static void loadTexture(Texture texture)
        {
            Struct str = Texture.getStruct();
            loadUniform(str.field("shineDamp"), texture.getShineDampening());
            loadUniform(str.field("reflectivity"), texture.getReflectivity());
        }
    }
}

do note that the files are working and the values have been passeed to the code... idk why this persists...